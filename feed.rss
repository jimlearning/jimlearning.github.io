<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>JimLearningBlog</title><description>A description of JimLearningBlog</description><link>https://jimlearning.github.io</link><language>zh</language><lastBuildDate>Fri, 12 Mar 2021 02:42:33 +0800</lastBuildDate><pubDate>Fri, 12 Mar 2021 02:42:33 +0800</pubDate><ttl>250</ttl><atom:link href="https://jimlearning.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://jimlearning.github.io/tips/script-with-swift</guid><title>Script with Swift</title><description>Learn how to run executable scripts in Swift.</description><link>https://jimlearning.github.io/tips/script-with-swift</link><pubDate>Tue, 28 Jan 2020 06:00:00 +0800</pubDate><content:encoded><![CDATA[<h2>Prerequisites</h2><p>To keep things simple we will assume you have access to a machine running macOS or Linux and have already installed Swift.</p><h2>How to script with swift</h2><img src="https://jimlearning.github.io/images/posts/swift-logo.svg" alt="Swift logo"/><p>If you are already a Swift developer, you should be familiar with the process of creating a Swift package, application or command line tool. Once you have created one of these you would usually need to build a binary and then place it in a executable path before it can be run from a Command Line Interface (CLI). Sometimes, however, we just want to write a script and execute it as is, rather than package it for deployment. This can be particularly useful if you'd like to use Swift in different stages of the software development lifecycle such as inside of your Continuous Integration or Continuous Deployment pipelines.</p><p>In such pipelines, it's typical to create a bash file and execute it. For example you could create a file called <code>hello-world</code> with the following contents:</p><pre><code>#!/usr/bin/env bash

echo <span class="string">"Hello, World!"</span>
</code></pre><p>You would then make it executable by running:</p><pre><code>chmod +x hello-world
</code></pre><p>And then execute it by running:</p><pre><code>./hello-world
</code></pre><p>But this is not just limited to runtime languages like bash, the comment on the first line tells the machine what program to use when interpreting the file. This means we can create and execute a script using the Swift programming language instead. For example, let's replace the contents of the <code>hello-world</code> file we created earlier with this:</p><pre><code>#!/usr/bin/env swift

<span class="call">print</span>(<span class="string">"Hello, World!"</span>)
</code></pre><p>Now you can execute the script by running the same command as we did earlier:</p><pre><code>./hello-world
</code></pre><p>Once again you should see the text <code>Hello, World!</code> printed to the console.</p><h2>Summary</h2><p>That's it! In this post we have demonstrated a simple way to build small Swift scripts that you can modify and run in place whenever you need to, without the need to recompile and deploy them.</p><h2>References</h2><ul><li><a href="https://swift.org/ "swift.org"">Swift</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://jimlearning.github.io/articles/github-actions</guid><title>Continuous Deployment with GitHub Actions and Docker Hub</title><description>In this post we will assume that you practice Continuous Integration (CI) and have a product which is packaged as a Docker image. As your next step you are looking to implement Continuous Deployment (CD) from scratch or move to it from a Continuous Delivery workflow. Our aim will be to build and push a docker image to Docker Hub using GitHub actions.</description><link>https://jimlearning.github.io/articles/github-actions</link><pubDate>Mon, 20 May 2019 16:25:00 +0800</pubDate><content:encoded><![CDATA[<h2>Principles</h2><p>Before we dive into how we can achieve this goal, it’s important to understand the principles behind what we are trying to achieve and why. If you’re already familiar with Continuous Delivery and Continuous Deployment as well as the distinction between the two, feel free to skip this next part.</p><h3>What is Continuous Delivery?</h3><p>Continuous Delivery is a software development discipline where you build software in such a way that the it can be released to production at any time<sup>[1]</sup>. In a Continuous Delivery workflow, each development change that is pushed to the main repository is ready to be shipped. However, the action of shipping requires human approval. Although there is usually a focus on automated testing as part of this process, in many organisations the risk of promoting a release to production is shouldered by the individual approving that release. Onus is placed on the developers to prioritise keeping the code deliverable over implementing new features.</p><h3>How does Continuous Delivery differ from Continuous Deployment?</h3><p>By contrast, in Continuous Deployment each development change that is pushed to the main repository is automatically released to production, without any human intervention. In this workflow, a strong emphasis is placed on automated testing, as it should not be possible to merge code into the main development branch without that code passing a test suite. This means that the quality of your test suite determines the level of risk for a release, and automated testing must be prioritised during development. As such it’s important to ensure you don’t fall into the trap of mistaking good code coverage in your test suite for good quality tests. Developers within the team must ensure that the quality of tests presented in code reviews remains high.</p><h2>Using Github actions for Continuous Deployment</h2><p>Now that we understand what Continuous Deployment is and what we are aiming for, let’s create a workflow that builds a Docker image and publishes it to Docker Hub. To begin, you’ll need to navigate to GitHub, ensure you are logged in and have opened the repository that you would like to work with. The repository should already contain a <code>Dockerfile</code>. Click the <em>Actions</em> button at the top of the page: <img src="https://jimlearning.github.io/images/posts/github-actions-title-bar.jpg" alt="GitHub actions button"/></p><p>GitHub will prompt you to confirm that you’d like to create a new workflow, click the <em>Create a new workflow</em> button: <img src="https://jimlearning.github.io/images/posts/github-actions-create-button.jpg" alt="Git hook screenshot"/></p><p>Leave the name of the file as <code>main.workflow</code> and click the button labelled <em>Edit file</em> <img src="https://jimlearning.github.io/images/posts/github-actions-heading.jpg" alt="Git hook screenshot"/></p><p>Add the following to the contents of the editor, replacing <code>&lt;project-name&gt;</code> and <code>&lt;docker-hub-username&gt;</code> with the name of your project and username for Docker Hub:</p><pre><code># <span class="type">Create</span> a new workflow that’s triggered by a push to master
workflow <span class="string">"Build on push"</span> {
  on = <span class="string">"push"</span>
  resolves = [
    <span class="string">"Push Docker image with build number"</span>,
    <span class="string">"Push Docker image with latest"</span>,
    <span class="string">"Archive release"</span>
  ]
}

# <span class="type">Optionally</span> add an action to run your test suite here

# <span class="type">Filter</span> pushes to only those on the master branch
action <span class="string">"Filter for master"</span> {
  uses = <span class="string">"actions/bin/filter@master"</span>
  args = <span class="string">"branch master"</span>
}

# <span class="type">Login</span> to <span class="type">Docker Hub</span> with your credentials (<span class="type">The GitHub UI</span> will prompt you <span class="keyword">for</span> them <span class="keyword">if</span> they have not already been provided).
action <span class="string">"Authenticate with Docker Registry"</span> {
  uses = <span class="string">"actions/docker/login@master"</span>
  needs = [<span class="string">"Filter for master"</span>]
  secrets = [<span class="string">"DOCKER_USERNAME"</span>, <span class="string">"DOCKER_PASSWORD"</span>]
}

# <span class="type">Build</span> a docker image based off of a <span class="type">Dockerfile</span> <span class="keyword">in</span> the root directory of the repository
action <span class="string">"Build Docker Image"</span> {
  uses = <span class="string">"actions/docker/cli@8cdf801b322af5f369e00d85e9cf3a7122f49108"</span>
  needs = [<span class="string">"Authenticate with Docker Registry"</span>]
  args = <span class="string">"build -f Dockerfile --tag &lt;project-name&gt; ."</span>
}

# <span class="type">Give</span> the docket image a unique tag based on the <span class="type">GitHub SHA</span>
action <span class="string">"Tag Docker Image with build number"</span> {
  uses = <span class="string">"actions/docker/cli@8cdf801b322af5f369e00d85e9cf3a7122f49108"</span>
  needs = [<span class="string">"Build Docker Image"</span>]
  args = <span class="string">"tag &lt;project-name&gt; &lt;docker-hub-username&gt;/&lt;project-name&gt;:$GITHUB_SHA"</span>
}

# <span class="type">Automatically</span> push the image to <span class="type">Docker Hub</span>
action <span class="string">"Push Docker image with build number"</span> {
  uses = <span class="string">"actions/docker/cli@8cdf801b322af5f369e00d85e9cf3a7122f49108"</span>
  needs = [<span class="string">"Tag Docker Image with build number"</span>]
  args = <span class="string">"push &lt;docker-hub-username&gt;/&lt;project-name&gt;:$GITHUB_SHA"</span>
}

# <span class="type">Filter</span> <span class="keyword">for</span> a tag which indicates that this push <span class="keyword">is</span> a release (i.<span class="property">e</span>. <span class="property">the</span> push <span class="keyword">is</span> tagged with v1.<span class="number">0.0</span>)
action <span class="string">"Filter for tag"</span> {
  uses = <span class="string">"actions/bin/filter@master"</span>
  needs = [<span class="string">"Push Docker image with build number"</span>]
  args = <span class="string">"tag v*"</span>
}

# <span class="type">Tag</span> the docket image <span class="keyword">as</span> latest
action <span class="string">"Tag Docker Image with latest"</span> {
  uses = <span class="string">"actions/docker/cli@8cdf801b322af5f369e00d85e9cf3a7122f49108"</span>
  needs = [<span class="string">"Filter for tag"</span>]
  args = <span class="string">"tag &lt;project-name&gt; &lt;docker-hub-username&gt;/&lt;project-name&gt;:latest"</span>
}

# <span class="type">Automatically</span> push the image tagged latest to <span class="type">Docker Hub</span>
action <span class="string">"Push Docker image with latest"</span> {
  uses = <span class="string">"actions/docker/cli@8cdf801b322af5f369e00d85e9cf3a7122f49108"</span>
  needs = [<span class="string">"Tag Docker Image with latest"</span>]
  args = <span class="string">"push &lt;docker-hub-username&gt;/&lt;project-name&gt;:latest"</span>
}

# <span class="type">Create</span> a release <span class="type">ZIP</span> archive and add it to the repository
action <span class="string">"Archive release"</span> {
  uses = <span class="string">"lubusIN/actions/archive@master"</span>
  needs = [<span class="string">"Filter for tag"</span>]
  env = {
    <span class="type">ZIP_FILENAME</span> = <span class="string">"&lt;project-name&gt;"</span>
  }
}
</code></pre><p>That was a lot to digest, so let’s take a look at the actions in this workflow. The workflow is trigged by any push to the repository. The first action filters out all pushes other than those to the master branch. It then attempts to login to Docker Hub using the credentials you have supplied as secrets.</p><p>Once authenticated, an action builds a Docker image, another tags it and yet another pushes it to Docker Hub. The next action is a filter, it checks if the push to the master branch was tagged as a release. If the push was a release then the next action tags the Docker image as latest and another pushes it to Docker Hub. Finally, an action zips the source code up and publishes it to the release page on GitHub.</p><p>To see all of this in action, commit the <code>main.workflow</code> file to the repository. Navigating to the actions tab should now show any in-progress builds as well as historical ones:</p><img src="https://jimlearning.github.io/images/posts/github-actions-run-results.jpg" alt="Git hook screenshot"/><h2>References</h2><ul><li><a href="https://martinfowler.com/bliki/ContinuousDelivery.html        "Martin Fowler - Continuous Delivery"">Martin Fowler - Continuous Delivery</a></li></ul>]]></content:encoded></item></channel></rss>