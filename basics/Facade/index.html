<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"/><meta name="og:site_name" content="JimLearningBlog"/><link rel="canonical" href="https://jimlearning.github.io/basics/Facade"/><meta name="twitter:url" content="https://jimlearning.github.io/basics/Facade"/><meta name="og:url" content="https://jimlearning.github.io/basics/Facade"/><title>Facades | JimLearningBlog</title><meta name="twitter:title" content="Facades | JimLearningBlog"/><meta name="og:title" content="Facades | JimLearningBlog"/><meta name="description" content="A look at what Facades are and how they can be used to provide a simplified interface to complex libraries and frameworks."/><meta name="twitter:description" content="A look at what Facades are and how they can be used to provide a simplified interface to complex libraries and frameworks."/><meta name="og:description" content="A look at what Facades are and how they can be used to provide a simplified interface to complex libraries and frameworks."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to JimLearningBlog"/></head><head><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Karla:400,400i,700,700i"/><link rel="stylesheet" href="/PersonalTheme/fontawesome/all.min.css"/></head><body><header><div class="wrapper"><a class="site-name" href="/">JimLearningBlog</a><p>A description of JimLearningBlog</p><nav><ul><li><a href="/posts"><span></span>Posts</a></li><li><a href="/articles"><span class="far fa-newspaper"></span>Articles</a></li><li><a href="/tips"><span class="far fa-star"></span>Tips</a></li><li><a href="/apps"><span></span>Apps</a></li><li><a href="/tags"><span class="fas fa-hashtag"></span>Tags</a></li><li><a href="/about"><span class="far fa-user"></span>About Me</a></li></ul></nav></div></header><div class="wrapper"><h2>Facade Pattern</h2><p>A <em>Facade</em> is an design pattern which provides a simplified <em>interface</em> that <em>encapsulates</em> the inernal implementation details of a larger more complex body of code or one which contains lots of moving parts. When working with such code this patttern can be used to <em>seperate concerns</em> from the consumer through a minimalist interface that only exposes the functionality that the consumer really cares about.</p><p>It this way it can thought of as analogous to a shield - as it shields the consumer from the complex details of the code and provides them with a simplified view which is easy to use. This reduces the learning curve required to successfully leverage the code which inturn typically promotes re-use.</p><p>While using the Facade design pattern gives you the opertunity to make an application easier to understand and integrate with, arguably its most important feature is that it promotes decoupling the underlying components of the application from consumers.</p><p>Decoupling your applications code can help you to ensure that it is easy to modify without breaking any consumers which may depend on it. It should be used in situations where consumers need a simple facilitator, one that exposes a simplified interface with a <em>limited</em> set of <em>course-grained</em> behaviors.</p><h2>Intent</h2><p>The intent behind a Facade is to provide a <em>course-grained interface</em> that:</p><ul><li>Offers convenient methods for common tasks that makes the code easier to read, use, understand and test</li><li>Reduces the dependencies from consumer code on the internal implementation components of your code, making it easier to change</li><li>Wraps a collection of poorly designed APIs within a single well-designed API</li></ul><h2>Problem</h2><p>As with any design pattern its important to understand examples of situations in which they can be useful, so lets look at common example where a consumer is trying to access your code remotely.</p><p>Within a single applications code base, fine-graned APIs can provide a developers with a large number of methods which can be chained together in flexible ways to produce new features for customers. However, one of the consequences of such fine-grained behavious is that interactions between components become tightly coupled and typically require lots of method invocations.</p><p>This becomes particularly problematic with remote calls which are often orders of magnitude more expensive to perform since they typically require data to be serialised, authentication and authorisation checks to be performed, packets to be sent accross a network and so on. As a result, a course-grained interface may be required in order to minimise the number of calls needed perform a function.</p><h2>Structure</h2><p>The diagram below provides an example of a coarse-grained interface that's intended to be used by remote consumers that want to minimuse the number of calls needed to get something done:</p><img src="/images/posts/Facade-structure.svg" alt="Facade structure"/><p>In this example all the facade does is transalte the coarse-grained methods it exposes into the underlying fine-grained methods in the Customer object.</p><h2>Related Patterns</h2><p>The <em>Facade</em> pattern can be used to mitigate some of the disadvantages of the <em>canonical data model</em> pattern. It does so by defining simplified interfaces that don't expose canonical models. It acts as a translator which means any changes to the underlying canonical model won’t directly impact the interfaces exposed or their consumers. This can be a great benefit when changes to the canonical model occur frequently or are not in your control.</p><p>One drawback of the <em>Facade</em> pattern in this regard is that can lead to an increased maintenance burden. It is not always practical to wrap and translate the whole canonical model as well as all of an applications underlying dependancies or third party libraries. This is because there is both an upfront cost for wrapping these components as well as a maintenance cost for managing changes for the transformation and integration logic over time.</p><h2>Summary</h2><p>Facades are a design pattern that can be used to simplify access to our code, by pre-defining a <em>limited</em> set of behaviours that can be called by a consumer.</p><p>That's a key part though, because Facades are only realy useful when the underlying code is complex, has many moving parts is difficult to understand or use. It often comes at the expense of limiting the features and flexibility available to consumers due to the maintenance cost of wrapping the underlying components.</p></div><footer class="animated fadeIn"><p>Mike Gough © 2020.</p><p>Powered by <a href="https://github.com/johnsundell/publish">Publish</a> and hosted on <a href="https://github.com/Mike-Gough/Mike-Gough.github.io">GitHub Pages</a>. 100% JavaScript-free.</p><p>Notice a broken link or other issue? <a href="https://github.com/Mike-Gough/Mike-Gough.github.io/issues">Open an issue!</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>